# Lab3 实验报告

下面对实验要求中的几个重点的相关设计思路进行阐述。



## Part 1

要求实现双人聊天，其重点在于以回车作为消息的分割符，并要求可以处理大小为1Mb级别的消息。

利用以下代码代码进行处理：不断以一个字符为单位进行`recv`操作，如果出现回车，进行发送操作，如果出现空间不足，使用`realloc`。由于是阻塞模式，如果`recv`返回不正常，说明客户端已经退出。在两人聊天部分不做处理。

处理大小为1M的消息，通过对`send`的结果进行记录，并在`send`不完整时利用`while`继续发送即可。由于为阻塞模式，实际上`send`一般不会出现不完整的情况。 

```
while (1){
        while (((status = recv(pipe->fd_send, buffer + length, 1, 0)) > 0) && (buffer[length] != '\n') && (length < block_len - 1)) length++;
        if (status <= 0) return NULL;
        if (buffer[length] == '\n') {
            int already_send_length = 0;
            int len;
            while( already_send_length < length + 1){
                len = send(pipe->fd_recv, buffer, length + 1 - already_send_length, 0);
                if (len > 0) already_send_length += len;
            }
            length = 8;
        }                          
        else {
            buffer = realloc(buffer, (block_len + 1024) * sizeof(char));
            block_len = block_len + 1024;
        }
    }
}
```



## Part 2

要求完成多线程多人聊天室。

由于完成时间较早，与推荐方案有些偏差。

思路如下： 建立一个`send_message` 线程，并在主线程每次`accept`后建立`recv`线程。`recv`线程与第一部分的代码类似，在消息需要发送时，使用同步互斥锁，并将消息拷贝至`send_buffer`中，并置发送信号。`send_message`线程在收到信号时会依次发送到各个clients，并在完成后解锁。这样的实现方式可能造成阻塞，但是由于时间限制没有进一步完善。

为了处理自由进出，本部分采用了数组与两个链表`Used`和`Unused`相配合。链表分别存储0~31中被使用和未被使用的数字，并在需要时从一个链表取结点，链至另一链表上。关于链表的操作同样需要使用线程锁来避免冲突。数组则存储某一id的client的具体信息。



***由于代码较长且复杂，不在报告中展示。代码中有相应注释，可以对照理解。**



## Part 3

要求使用`select`完成非阻塞异步I/O的多人聊天室。

#### 思路

主要分为四大部分，分别为`accept`, `recieve`, `send`, 消息管理。

在`main`函数中使用`while(1)`，并在循环内依次处理上面四个部分。

`accept`为针对 server 的`select`, 当`select`成功时完成记录新client的工作。

`recieve`最为复杂，对clients使用`select`要处理客户端退出、消息正常发送、消息未由`\n`结尾、空间不足四种情况，之后详细介绍。

`send`部分，同样使用`select`，当某一客户端可以发送消息时，会看该客户端是否有待发送的消息，如果有则发送。

消息管理部分主要目的为处理已向所有客户端发送的无用消息，及时释放内存。

#### 数据结构

针对clients，使用与第二部分一样的链表+数组结构。

消息方面，使用一个消息队列，所有要发送的消息都会被置入队列。而每一个客户端都还可能有未以`\n`结尾的消息，这些消息利用一个数组统一管理。

针对每一个client进行消息处理的部分，使用一个结构体，其中包括指向当前消息的指针，待发送长度，已发送长度，消息编号（为方便释放无用消息，对消息顺序编号）等。

这样的设计可以避免为每一个client维护消息队列，大大减少空间负担，并且可以及时释放无用空间。

#### `recieve`具体设计

与之前的部分相似，同样每次读入一个字符，这样一来如果读到`\n`可以直接转入处理。

空间不足同样较好判断，当要溢出时直接进行`realloc`。

而当`recv`的结果为零时，需要区分没读到任何数据（client退出）和经过很多个循环，未读到`\n`的情况。这里利用一个`flag`进行标志。



***由于代码较长且复杂，不在报告中展示。代码中有相应注释，可以对照理解。**



## 运行结果

- 均可以完成1Ｍ大小的数据传输

- 第二第三部分 可以自由进出 客户端数量为0也不会退出

- 换行符为分割

  

  ***如有意外情况麻烦助教私聊（（（**

  